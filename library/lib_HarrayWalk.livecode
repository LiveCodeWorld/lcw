script "lib_HarrayWalk"
--> MetaData
-
license: GPLv3
name: lib_HarrayWalk
type: script library
version: 0.2


--> Walk Array
-
function walkArray_GetMainstackHash walkArray
   return walkArray ["hArray"]["metadata"]["sha1"]
end walkArray_GetMainstackHash

command walkArray_SetMainstackHash @walkArray, mainstackHash
   put mainstackHash into walkArray ["hArray"]["metadata"]["sha1"]
end walkArray_SetMainstackHash


--> Hkey | Deps | From Object
-
function hkey_DependencyArrayFromObjects hKeys, pSetName, pAllCalls
   local hKeyLinkArray
   try  
      repeat for each line hKey in hkeys
         -- should this be hkey_GetHandler - anywhere from hierarchy ????
         put hkey_ExtractHandlerFromObject (hKey) into someHandler
         if pAllCalls is true then
            put handler_ExtractCalls (someHandler) into shortCalls
         else
            put handler_ExtractFilteredCalls (someHandler) into shortCalls
         end if
         
         repeat for each line shortCall in shortCalls
            hkey_ObjectWalk shortCall, hKey, hKeyLinkArray, pSetName, pAllCalls
         end repeat
      end repeat
      return hKeyLinkArray
   catch e -- script is locked
      return empty
   end try
end hkey_DependencyArrayFromObjects

function hkey_SmartFind shortCall, hKey, pSetName
   try
      hkey_Deconstruct hKey, hName, hType, hObject, hNum
      put item 1 of shortCall into callName
      put item 2 of shortCall into callType
      
      put hkey_FindInHierarchy (shortCall, hObject, pSetName) into foundCall
      if foundCall is empty then
         put item 1 of shortCall into callName
         put item 2 of shortCall into callType
         put hkey_FindAndIndex (callName, callType, hObject, pSetName) into foundCall
      end if
      return foundCall
   catch e
      breakpoint
      opn_Notify e, true
      exit to top
   end try
end hkey_SmartFind

command hkey_SimpleWalk shortCall, hKey, @hKeyLinkArray, pSetName, pTestExceptions, pOriginalHkey
   -- mixed up but working, test based walk, of objects and stuff
   -- use an object, library, or project walk instead.
   
   if pOriginalHkey is empty then put hKey into pOriginalHkey
   if the commandkey is "Down" and the optionKey is "Down" then
      hkey_Deconstruct pOriginalHkey, oHandlerName, oHandlerType, oScriptObject, oHandlerNum
      put "Currently indexing" && kwote (hKey) into pTitle
      display_ObjectHKeyArray hKeyLinkArray, oScriptObject, empty, empty, pTitle
      put the result into treeView
      set the displayed_Hkey of treeView to hKey
      
      -- allow storing of work-in-progress (by refering to last hKey)
      -- give an export!
      breakpoint
   end if
   
   -- find it
   local foundHKey, foundHandler
   hkey_Deconstruct hKey, hName, hType, hObject, hNum
   put item 1 of shortCall into callName
   put item 2 of shortCall into callType
   
   try
      -- put hArray_FindHkeyInHierarchy (shortCall, hObject) into foundCall
      put hkey_FindInHierarchy (shortCall, hObject, pSetName) into foundCall
      if foundCall is empty then
         put hkey_FindAndIndex (callName, callType, hObject, pSetName) into foundCall
      end if
   catch e
      opn_Notify e, true
      exit to top
   end try
   
   switch
      case foundCall is empty
         if hkey_MissingHandlerIsNotImportant (callName, callType) is true then return empty
         
         -- it's missing and should not be!
         -- hope it is not "dispatch" :)
         put merge ("Call '[[shortCall]]' for handler '[[hKey]]' is missing!") into someMessage
         opn_Notify someMessage, true
         
         put hkey_Construct (callName, callType, "missing", 1) into foundCall
         array_AddToIndex foundCall, hKey, hKeyLinkArray
         return empty
      case foundCall is among the keys of hKeyLinkArray
         -- found it (ie not empty), but...
         -- but we do need to add it to the array!
         array_AddToIndex foundCall, hKey, hKeyLinkArray
         
         -- already indexed so no need to recurse
         return empty
      default
         -- continue
   end switch
   
   -- hack for exceptions
   if pTestExceptions is true then
      if hkey_DontRecurse (foundCall, pOriginalHkey) is true then
         return empty
      end if
   end if
   
   -- add it to the array
   put merge ("Added [[foundCall]] to hKeyArray!") into someMessage
   opn_Notify someMessage
   array_AddToIndex foundCall, hKey, hKeyLinkArray
   
   -- now lets repeat and recurse for each call found
   put hkey_GetHandler (foundCall) into callHandler
   if callHandler is empty then breakPoint
   put handler_ExtractCalls (callHandler) into shortCalls -- should also return the type of call (ie "dispatch")?
   
   -- store them for future fast searches
   -- hkey_StoreCallsAndHandler foundCall, callHandler, shortCalls
   
   repeat for each line shortCall in shortCalls
      hkey_SimpleWalk shortCall, foundCall, hKeyLinkArray, pSetName, pTestExceptions, pOriginalHkey
   end repeat
   return empty
end hkey_SimpleWalk


--> Library | Walk
-
/*
These handlers use the library hanlder database (stored in an array and accessed with "library_GetHandlerDatabaseMetadata"). 
They don't do live testing, but instead use the stored pre-filtered calls in the hArray.
*/

command library_HandlerWalk shortCall, shortParentHkey, @hKeyLinkArray, pAllcalls
   set the cursor to busy
   put item 1 to 2 of shortCall into shortCall
   put item 1 to 2 of shortParentHkey into shortParentHkey
   
   put the keys of hKeyLinkArray [shortParentHkey] into alreadyCalled
   if shortCall is among the lines of alreadyCalled then return empty  -- already indexed, and we don't want to get stuck in a recursion loop
   
   if shortParentHkey is not empty then
      put empty into hKeyLinkArray [shortParentHkey][shortCall]
   end if
   
   if pAllcalls is true then
      put library_GetCalls (shortCall) into childCalls
   else
      -- put library_FetchHkeyCalls (hKey) into childCalls -- from text file
      put library_GetFilteredCalls (shortCall) into childCalls
   end if
   
   repeat for each line childCall in childCalls
      library_HandlerWalk childCall, shortCall, hKeyLinkArray, pAllcalls
   end repeat
   return empty
end library_HandlerWalk


--> Project | Walk
-
/*
These handlers use "hArray" only (no objects or file based info). 
They don't do live testing, but instead use the stored pre-filtered calls in the hArray.
*/

getprop object_HkeyArray [pSetName]
   local walkArray
   put the rugged_ID of the target into rObject
   put the script_Hkeys of rObject into hKeys
   put the mainstack_WalkArray [true] of rObject into walkArray
   
   delete variable walkArray ["hKeyArray"]
   
   repeat for each line parentHkey in hKeys
      set the cursor to busy
      put hArray_GetShortCalls (parentHkey) into shortCalls
      repeat for each line shortCall in shortCalls
         project_DependencyWalk shortCall, parentHkey, walkArray
      end repeat
   end repeat
   
   put walkArray ["hKeyArray"] into mainStackHkeyArray
   array_StripDeeperLevels mainStackHkeyArray
   put mainStackHkeyArray into walkArray ["hKeyArray"]
   return walkArray
end object_HkeyArray

function project_ConstructHkeyArray hArray, pDepObject, pSetName
   -- non-recursive version
   local hkeyArray
   
   if exists (pDepObject) then
      put revRuggedID (pDepObject) into pDepObject
      hArray_RemoveObjectFromArray pDepObject, hArray 
   end if
   put hArray ["scriptArray"] into objectArray
   
   repeat for each key rObject in objectArray
      put objectArray [rObject] into scriptObjectArray
      put scriptObjectArray ["data"]["firstHkeyArray"] into firstHkeyArray
      
      repeat for each key firstShortHkey in firstHkeyArray
         set the cursor to busy
         if firstShortHkey = "_,c" then next repeat -- could check handler is empty
         
         put firstShortHkey,rObject,1 into hKey
         put empty into hkeyArray [hKey]
         
         put hArray_GetShortCalls (hKey, hArray) into shortCalls
         repeat for each line shortHkey in shortCalls
            set the cursor to busy
            put hArray_FindHkeyInHierarchy (shortHkey, rObject, hArray, pSetName) into hkeyCall
            if hkeyCall is empty then
               -- put hArray_FindHkeyInHierarchy (shortHkey, rObject, empty, pSetName) into hkeyCall
               put hkey_FindInHierarchy (shortHKey, rObject, pSetName) into hkeyCall
               if hkeyCall is empty then
                  put shortHkey,"missing",1 into hkeyCall
               end if
            end if
            put empty into hkeyArray [hKey][hkeyCall]
         end repeat
      end repeat
   end repeat
   
   array_StripDeeperLevels hkeyArray
   return hkeyArray
end project_ConstructHkeyArray

function project_ConstructWalkArray hArray, pDepObject, pSetName
   -- non-recursive version
   local hkeyArray
   
   if exists (pDepObject) then
      put revRuggedID (pDepObject) into pDepObject
      hArray_RemoveObjectFromArray pDepObject, hArray 
   end if
   put hArray ["scriptArray"] into objectArray
   
   repeat for each key rObject in objectArray
      put objectArray [rObject] into scriptObjectArray
      put scriptObjectArray ["data"]["firstHkeyArray"] into firstHkeyArray
      
      repeat for each key firstShortHkey in firstHkeyArray
         set the cursor to busy
         if firstShortHkey = "_,c" then next repeat -- could check handler is empty
         
         put firstShortHkey,rObject,1 into hKey
         put empty into hkeyArray [hKey]
         
         put hArray_GetShortCalls (hKey, hArray) into shortCalls
         repeat for each line shortCall in shortCalls
            set the cursor to busy
            put hArray_FindHkeyInHierarchy (shortCall, rObject, hArray, pSetName) into foundCall
            if foundCall = hKey then put empty into walkArray ["recursive call"][hKey][shortCall]
            
            if foundCall is empty then
               -- put hArray_FindHkeyInHierarchy (shortHkey, rObject, empty, pSetName) into foundCall
               put hkey_FindInHierarchy (shortCall, rObject, pSetName) into foundCall
               if foundCall is empty then
                  put shortCall,"missing",1 into missingCall
                  put missingCall into walkArray ["missing"][shortCall][hKey]
               else
                  put foundCall into walkArray ["external"][shortCall][hKey]
               end if
            end if
            put empty into hkeyArray [hKey][foundCall]
         end repeat
      end repeat
   end repeat
   
   array_StripDeeperLevels hkeyArray
   put hkeyArray into walkArray ["hkeyArray"]
   put hArray into walkArray ["hArray"]
   return walkArray
end project_ConstructWalkArray


-- function project_ConstructWalkArray hArray, pDepObject
breakpoint
-- recursive version (no need for recursion use "project_ConstructHkeyArray" instead)
-- walkArray has the following keys:  hArray, external,hKeyArray,missing
-- local walkArray

if exists (pDepObject) then
   put revRuggedID (pDepObject) into pDepObject
   hArray_RemoveObjectFromArray pDepObject, hArray 
end if
put hArray ["scriptArray"] into objectArray
put hArray into walkArray ["hArray"]

repeat for each key rObject in objectArray
   put objectArray [rObject] into scriptObjectArray
   put scriptObjectArray ["data"]["firstHkeyArray"] into firstHkeyArray
   
   repeat for each key firstShortHkey in firstHkeyArray
      if firstShortHkey = "_,c" then next repeat -- could check handler is empty
      
      put firstShortHkey,rObject,1 into hKey
      put empty into walkArray ["hkeyArray"][hKey]
      
      put hArray_GetShortCalls (hKey, hArray) into shortCalls
      repeat for each line shortCall in shortCalls
         project_DependencyWalk shortCall, hKey, walkArray
      end repeat
   end repeat
end repeat

put walkArray ["hKeyArray"] into mainStackHkeyArray
array_StripDeeperLevels mainStackHkeyArray
put mainStackHkeyArray into walkArray ["hKeyArray"]
return walkArray
end project_ConstructWalkArray

command project_DependencyWalk shortCall, hKey, @walkArray
   -- simplified to only walk inside an indexed project without any checks
   put walkArray ["hArray"] into hArray
   put item 3 of hKey into hObject
   if exists(hObject) is false then
      breakpoint
      return empty
   end if
   
   try
      put hArray_FindHkeyInHierarchy (shortCall, hObject, hArray, pSetName) into foundCall
   catch e
      breakpoint
   end try
   
   switch
      case foundCall is among the keys of walkArray ["hKeyArray"]
         # still need to add the hKey but we don't want to recurse
         return empty
      case foundCall is hKey
         -- it's a recursive call, pass or get/setprop with lock messages?
         put empty into walkArray ["hKeyArray"][hKey][foundCall] -- think we should add it ???
         try
            put hArray_GetHandler (hKey, hArray) into callHandler -- for a peak
            put callHandler into walkArray ["recursive call"][hKey][shortCall]
         catch e
            breakpoint
         end try
         put merge ("Found a recursive call '[[hKey]]'. Skipping!") into someMessage
         opn_Notify someMessage, true
         return empty
      case foundCall is empty
         # an external or missing call 
         try
            put hArray_FindHkeyInHierarchy (shortCall, hObject) into foundCall -- could find from mainstack for external call?
         catch e
            breakpoint
         end try
         
         if foundCall is empty then
            put shortCall,"missing",1 into foundCall
            put foundCall into walkArray ["missing"][shortCall][hKey]
         else
            put foundCall into walkArray ["external"][shortCall][hKey]
         end if
         put empty into walkArray ["hKeyArray"][hKey][foundCall] -- think we should add it ???
         return empty
      default
         -- normal
   end switch
   
   -- add it to the array
   put empty into walkArray ["hKeyArray"][hKey][foundCall]
   put merge ("Added [[foundCall]] to hKeyArray!") into someMessage
   opn_Notify someMessage
   
   put item 3 of foundCall into foundObject
   if exists (foundObject) is false then
      breakpoint
      put foundCall into walkArray ["missing objects"][foundObject]
      return empty
   end if
   
   put hArray_GetShortCalls (foundCall, hArray) into shortCalls
   
   repeat for each line shortCall in shortCalls
      project_DependencyWalk shortCall, foundCall, walkArray
   end repeat
   return newlyExportedHkeyArray
end project_DependencyWalk


--> Harray | Walk | With Tests
-
/*
These handlers use "hArray_DependencyWalk" and test exceptions.
*/

function hkey_ConstructHarrayWalkArray hKeys, hArray, pSearchOutSideMainStack
   -- uses local main stack export data
   local walkArray
   if pTestExceptions is empty then put true into pTestExceptions
   if pSetName is empty then put "Menus Only" into pSetName
   
   repeat for each line hKey in hKeys
      put hkey_FetchShortCalls (hKey) into shortCalls
      repeat for each line shortCall in shortCalls
         hArray_DependencyWalk shortCall, hKey, walkArray, pSearchOutSideMainStack, pSetName, pTestExceptions
      end repeat
   end repeat
   
   -- changing hKeyArray functions to use keys instead of lines would avoid this step and speed things
   put walkArray ["hKeyArray"] into mainStackHkeyArray
   array_StripDeeperLevels mainStackHkeyArray
   put mainStackHkeyArray into walkArray ["hKeyArray"]
   return walkArray
end hkey_ConstructHarrayWalkArray

function hArray_WalkHkeyDeps hKeys, pSearchOutSideMainStack
   -- uses global hArray
   local walkArray, pSetName, pTestExceptions, pOriginalHkey
   repeat for each line hKey in hKeys
      set the cursor to busy
      put empty into walkArray ["hKeyArray"][hKey]
      put hArray_GetShortCalls (hKey) into shortCalls
      repeat for each line shortCall in shortCalls
         hArray_DependencyWalk shortCall, hKey, walkArray, pSearchOutSideMainStack, pSetName, pTestExceptions, pOriginalHkey
      end repeat
   end repeat
   put walkArray ["hKeyArray"] into mainStackHkeyArray
   array_StripDeeperLevels mainStackHkeyArray
   put mainStackHkeyArray into walkArray ["hKeyArray"]
   return walkArray
end hArray_WalkHkeyDeps

function hArray_WalkArray hArray, mainStackFolder, pDepObject, pSetName, pTestExceptions, pSearchHierarchy, pSearchOutSideMainStack
   local walkArray, pOriginalHkey
   if pTestExceptions is empty then put true into pTestExceptions
   if pSetName is empty then put "Menus Only" into pSetName
   
   if exists (pDepObject) then
      put revRuggedID (pDepObject) into pDepObject
      hArray_RemoveObjectFromArray pDepObject, hArray 
   end if
   put hArray ["scriptArray"] into objectArray
   put hArray into walkArray ["hArray"]
   
   repeat for each key rObject in objectArray
      if exists (rObject) is false then
         breakpoint
         next repeat -- error check (should not be!_
      end if
      put objectArray [rObject] into scriptObjectArray
      put scriptObjectArray ["data"]["firstHkeyArray"] into firstHkeyArray
      
      repeat for each key firstShortHkey in firstHkeyArray
         if firstShortHkey = "_,c" then next repeat -- could check handler is empty
         
         put firstShortHkey,rObject,1 into hKey
         put empty into walkArray ["hkeyArray"][hKey]
         
         put hArray_GetShortCalls (hKey, hArray) into shortCalls
         -- put hArray_GetHandler (hKey, hArray) into callHandler
         -- put handler_ExtractCalls (callHandler) into shortCalls
         repeat for each line shortCall in shortCalls
            hArray_DependencyWalk shortCall, hKey, walkArray, pSearchOutSideMainStack, pSetName, pTestExceptions, pOriginalHkey
         end repeat
      end repeat
   end repeat
   
   -- changing hKeyArray functions to use keys instead of lines would avodi this step and speed things
   put walkArray ["hKeyArray"] into mainStackHkeyArray
   array_StripDeeperLevels mainStackHkeyArray
   put mainStackHkeyArray into walkArray ["hKeyArray"]
   
   return walkArray
end hArray_WalkArray

command hArray_DependencyWalk shortCall, hKey, @walkArray, pSearchOutSideMainStack, pSetName, pTestExceptions, pOriginalHkey, pFindAndIndex, pExportHandlers
   /*
   Aims to do the same as "hArray_SimpleWalk" but faster using indexed arrays.
   Modified to use empty array index for hkeyArray (needs tidying with "array_StripDeeperLevels),
   and uses nested "walkArray" to store info other than hkeyArray
   */ 
   if pOriginalHkey is empty then put hKey into pOriginalHkey
   -- put shortCall & CR & hKey
   
   if the commandkey is "Down" and the optionKey is "Down" then
      hkey_Deconstruct pOriginalHkey, oHandlerName, oHandlerType, oScriptObject, oHandlerNum
      put "Currently indexing" && kwote (hKey) into pTitle
      display_ObjectHKeyArray hkeyArray, oScriptObject, empty, empty, pTitle
      put the result into treeView
      set the displayed_Hkey of treeView to hKey
      breakpoint  -- allow storing of work-in-progress (by refering to last hKey)
   end if
   
   -- find it
   put walkArray ["hArray"] into hArray
   put item 3 of hKey into hObject
   put hArray_FindHkeyInHierarchy (shortCall, hObject, hArray, pSetName) into foundCall
   
   if item 4 of foundCall > 1 then
      breakpoint
      put hArray_FindHkeyInHierarchy (shortCall, hObject, hArray, pSetName) into foundCall
   end if
   
   if foundCall is empty and pFindAndIndex is true then
      try -- find and index along the way
         put item 1 of shortCall into callName
         put item 2 of shortCall into callType
         put hkey_FindAndIndex (callName, callType, hObject, pSetName) into foundCall
      catch e
         opn_Notify e, true
         breakpoint
      end try
   end if
   
   switch
      case foundCall is among the keys of walkArray ["hKeyArray"]
         # still need to add the hKey -> foundCall link as foundCall may have been added to another handler
         # but we don't want to recurse
         put true into dontRecurse
         break
      case foundCall is hKey
         -- if shortCall = item 1 to 2 of hKey then
         -- it's a recursive call, pass or get/setprop with lock messages?
         -- not 100% sure what to do here (for nwo we ignore)
         -- or whether to do it here or at top of handler
         -- take a deeper look when adding "pass" hierarchy parsing
         
         put empty into walkArray ["hKeyArray"][hKey][foundCall] -- think we should add it ???
         
         put hArray_GetHandler (hKey, hArray) into callHandler -- for a peak
         put callHandler into walkArray ["recursive call"][hKey][shortCall]
         put merge ("Found a recursive call '[[hKey]]'. Skipping!") into someMessage
         opn_Notify someMessage, true
         
         return empty
         -- end if
      case foundCall is empty
         # an external or missing call
         
         put item 1 of shortCall into callName
         put item 2 of shortCall into callType
         
         -- hack to ignore some calls like uXXX getprops etc
         if hkey_MissingHandlerIsNotImportant (callName, callType, hkey) is true then
            put merge ("Call '[[shortCall]]' for handler '[[hKey]]' is missing - but ignoring as 'hkey_MissingHandlerIsNotImportant()'!") into someMessage
            opn_Notify someMessage, true
            return empty
         end if
         
         put hArray_FindHkeyInHierarchy (shortCall, hObject) into foundCall -- could find from mainstack for external call?
         if foundCall is empty then
            put foundCall into walkArray ["missing"][shortCall][hKey]
         else
            put foundCall into walkArray ["external"][shortCall][hKey]
         end if
         
         put pSearchOutSideMainStack is not false into dontRecurse
         break
      default
         -- normal
   end switch
   
   if item 4 of foundCall > 1 then
      breakpoint
      put hArray_GetShortCalls (foundCall, hArray) into shortCalls
   end if
   
   -- pre-test
   -- hack for exceptions (try to get rid of this code / minimize the number of tests)
   if pTestExceptions is true and deps_DontAddOrRecurse (foundCall, pOriginalHkey, hArray) is true then
      put empty into walkArray ["dontRecurse"][hKey][foundCall]
      put merge ("Skipping recursion without adding [[foundCall]]!") into someMessage
      opn_Notify someMessage
      return empty
   end if
   
   -- add it to the array
   put empty into walkArray ["hKeyArray"][hKey][foundCall]
   put merge ("Added [[foundCall]] to hKeyArray!") into someMessage
   opn_Notify someMessage
   
   -- post-tests
   if dontRecurse is true or pTestExceptions is true and deps_DontRecurse (foundCall, pOriginalHkey, hArray) is true then
      put merge ("Skipping recursion for [[foundCall]]!") into someMessage
      opn_Notify someMessage
      return empty
   end if
   
   put item 3 of foundCall into foundObject
   if exists (foundObject) is false then
      breakpoint
      put foundCall into walkArray ["missing objects"][foundObject]
      return empty
   end if
   
   if pFindAndIndex is true then
      -- this will slow things down a bit (maybe stop checking)?
      put hArray_GetObjectMetaData (foundObject, "sha1", hArray) into scriptHash
      try
         put the script of foundObject into someScript
         put sha1_Hash (someScript) = scriptHash into indexIsUpToDate
      catch e
         put foundCall into walkArray ["locked objects"][foundObject]
         return empty
      end try
      
      if indexIsUpToDate is false then
         -- think we shoud do this regardless of pFindAndIndex
         put pref_GetValue ("Construct hashArray on stack export") into pCreateHashArray
         object_AddToArray hArray, foundObject, someScript, pExportHandlers, pCreateHashArray
         put empty into walkArray ["reindexed"][foundObject]
      end if
   end if
   
   -- put hkey_FetchShortCalls (foundCall, hArray) into shortCalls
   -- put hArray_GetHandler (foundCall, hArray) into callHandler
   -- put handler_ExtractCalls (callHandler) into shortCalls
   put hArray_GetShortCalls (foundCall, hArray) into shortCalls
   
   repeat for each line shortCall in shortCalls
      hArray_DependencyWalk shortCall, foundCall, walkArray, pSearchOutSideMainStack, pSetName, pTestExceptions, pOriginalHkey, pFindAndIndex
   end repeat
   return newlyExportedHkeyArray
end hArray_DependencyWalk

function hkey_MissingHandlerIsNotImportant callName, callType, hKey
   switch
      case callType is among the items of "g,s" and char 1 of callName = "u"
         return true
      case callType is among the items of "g,s" and "_" is not in callName
         return true
      case char 1 to 3 of callName = "rev" and char 4 of callName is not "_"
         put "Skipping LiveCode handler:" && callName,callType into someMessage
         put CR & CR & "It should not have been indexed as a LiveCode IDE handler, please add to dictionary!" after someMessage
         opn_Notify someMessage, true
         return true
      case the number of words of callName > 1
         -- bug - often "default -- case"
         put merge ("Bug with call '[[shortCall]]' for handler '[[hKey]]'") into someMessage
         opn_Notify someMessage, true
         return true
      default
         return false
   end switch
end hkey_MissingHandlerIsNotImportant

function deps_DontRecurse hKey, pOriginalHkey, hArray
   -- remember can also do this after collecting everything
   -- the purpse here is to stop unecessarily long recursion
   hkey_Deconstruct hKey, hName, hType, hObject, hNum
   put library_FetchHandler (hKey) into someHandler
   
   put pref_GetValue ("skip_HkeyComponents") is not false into skipHkeyComponents
   switch
      case hkey_IsAuthored (hKey, hArray) is false
         return true
      case the object_MetaData ["component"] of hObject is true and skipHkeyComponents is true
         return false
      case hObject contains "View|Menu|Button" and "View|Menu|Button" is not in pOriginalHkey
         return false -- not needed because of the above
      case hObject contains "View|Title|Right Align" and "View|Title|Right Align" is not in pOriginalHkey
         if hType is among the items of "g,s" then
            return true
         else
            return false
         end if
      case line 2 of someHandler contains "-- custom: true"
         return false
      case line 2 of someHandler contains "-- component: true"
         return true
      case hName begins with "display_"
         return true
      case lineoffset ("name: View|", someHandler) is not 0 and hType is among the items of "g,s"
         -- skip a handler in a views behavior, when it is called outside of the view and it is a getprop or setprop.
         breakpoint
         hkey_Deconstruct pOriginalHkey, oName, oType, oObject, oNum
         return the long id of hObject = the long id of oObject 
      case hName is among the items of "opn_Notify"
         return true
      case hName begins with "tree_" and hType is among the items of "g,s"
         return false
      default
         return false
   end switch
end deps_DontRecurse

function deps_DontAddOrRecurse hKey, pOriginalHkey, hArray
   -- remember can also do this after collecting everything
   -- the purpse here is to stop unecessarily long recursion
   return false
end deps_DontAddOrRecurse


--> Old | Simple | Walk
-
getprop hkey_DependencyArray [pSetName]
   put the long id of the target into scriptObject
   put script_GetSimpleDependencyArray (scriptObject, pSetName, true) into hKeyLinkArray
   return hKeyLinkArray
end hkey_DependencyArray


--> Old | Hkey | Walk
-
-- function hkey_ConstructDependencyArray hkey, pSetName, pTestExceptions, pOriginalHkey
-- local hKeyLinkArray
-- this is the older non-hArray version

hkey_Deconstruct hKey, hName, hType, hObject, hNum
try
   put the script of hObject into someScript
   
   put false into notPrivate 
   put script_ExtractHandler (hKey, someScript, false) into someHandler
   put handler_ExtractCalls (someHandler) into shortCalls
   
   -- now we have shortCall and hKey (let's recurse)
   repeat for each line shortCall in shortCalls
      hkey_SimpleWalk shortCall, hKey, hKeyLinkArray, pSetName, pTestExceptions, pOriginalHkey
   end repeat
   return hKeyLinkArray
catch e -- script is locled
   return empty
end try
end hkey_ConstructDependencyArray

function hkey_ScriptDependencyArray hKeys, pMaxDepth, pDontRecurseOutside, pOriginalHkey, pTestExceptions, pForceSearch, pEnvironmentalFilter
   -- hkeys will usually come from "put the script_Hkeys of the target into hkeys"
   -- use "hkey_ConstructDependencyArray"
   
   local hKeyLinkArray
   if pMaxDepth is not a number then put the overlay_MaximumDepth of me into pMaxDepth
   repeat for each line hKey in hkeys
      if pDontRecurseOutside is not empty then
         put true into pDontRecurseOutside
         put hKey into pOriginalHkey
      end if
      hkey_WalkHierarchy hKey, hKeyLinkArray, 0, pMaxDepth, pDontRecurseOutside, pOriginalHkey, pEnvironmentalFilter, pTestExceptions, pForceSearch
   end repeat
   return hKeyLinkArray
end hkey_ScriptDependencyArray

function script_GetSimpleDependencyArray scriptObject, pSetName, pTestExceptions, pFromObject
   local hKeyLinkArray
   
   if pFromObject is true then 
      put the script_Hkeys of scriptObject into hkeys
   else
      if the hArray_ObjectIndexCurrent of scriptObject is false then
         object_AddToGlobalArray scriptObject
      end if
      put the hArray_FirstHkeys of scriptObject into hkeys
   end if
   
   try
      if pFromObject is true then put the script of scriptObject into someScript
      
      put false into notPrivate 
      repeat for each line hKey in hkeys
         put item 3 of hkey into someObject
         if the hArray_ObjectIndexCurrent of someObject is false then
            object_AddToGlobalArray someObject
         end if
         
         put hkey_GetCalls (hKey) into shortCalls
         repeat for each line shortCall in shortCalls
            hArray_SimpleWalk shortCall, hKey, hKeyLinkArray, pSetName, pTestExceptions, hKey
         end repeat
      end repeat
      array_StripDeeperLevels hKeyLinkArray
      return hKeyLinkArray
   catch e -- script is locked
      return empty
   end try
end script_GetSimpleDependencyArray

command hArray_SimpleWalk shortCall, hKey, @hKeyLinkArray, pSetName, pTestExceptions, pOriginalHkey
   /*
   Aims to do the same as "hArray_SimpleWalk" but faster using indexed arrays.
   Modified to use empty array index for hkeyLinkArray (needs tidying with "array_StripDeeperLevels"
   */
   breakpoint
   local newlyExportedHkeyArray
   
   if pOriginalHkey is empty then put hKey into pOriginalHkey
   
   if the commandkey is "Down" and the optionKey is "Down" then
      hkey_Deconstruct pOriginalHkey, oHandlerName, oHandlerType, oScriptObject, oHandlerNum
      put "Currently indexing" && kwote (hKey) into pTitle
      display_ObjectHKeyArray hKeyLinkArray, oScriptObject, empty, empty, pTitle
      put the result into treeView
      set the displayed_Hkey of treeView to hKey
      breakpoint  -- allow storing of work-in-progress (by refering to last hKey)
   end if
   
   -- find it
   local foundHKey, foundHandler
   hkey_Deconstruct hKey, hName, hType, hObject, hNum
   put item 1 of shortCall into callName
   put item 2 of shortCall into callType
   
   try
      put hArray_FindHkeyInHierarchy (shortCall, hObject) into foundCall
      if foundCall is empty then
         put hkey_FindAndIndex (callName, callType, hObject, pSetName) into foundCall
      end if
   catch e
      opn_Notify e, true
      breakpoint
   end try
   
   switch
      case foundCall is empty
         if hkey_MissingHandlerIsNotImportant (callName, callType) is true then return empty
         
         -- it's missing and should not be! -- hope it is not "dispatch" :)
         put merge ("Call '[[shortCall]]' for handler '[[hKey]]' is missing!") into someMessage
         opn_Notify someMessage, true
         
         put hkey_Construct (callName, callType, "missing", 1) into foundCall
         
         -- array_AddToIndex foundCall, hKey, hKeyLinkArray
         put empty into hKeyLinkArray [hKey][foundCall]
         return empty
      case foundCall is among the keys of hKeyLinkArray
         -- found it, but we do need to add it to the array!
         -- array_AddToIndex foundCall, hKey, hKeyLinkArray
         put empty into hKeyLinkArray [hKey][foundCall]
         
         -- already indexed so no need to recurse
         return empty
      default
         -- continue
   end switch
   
   -- hack for exceptions
   if pTestExceptions is true and hkey_DontRecurse (foundCall, pOriginalHkey) is true then return empty
   
   -- add it to the array
   put merge ("Added [[foundCall]] to hKeyArray!") into someMessage
   opn_Notify someMessage
   -- array_AddToIndex foundCall, hKey, hKeyLinkArray
   put empty into hKeyLinkArray [hKey][foundCall]
   
   
   -- now lets repeat and recurse for each call found
   put item 3 of foundCall into foundObject
   if the hArray_ObjectIndexCurrent of foundObject is false then
      -- hArray_IndexAndStoreHandlerAndCalls foundCall -- should be a lot faster
      hArray_IndexAndStoreScriptAndAllHkeyCalls foundObject -- take opportunity to fully index a new object
      get the result 
      union newlyExportedHkeyArray with it
   else
      put hArray_GetHandler (foundCall) into callHandler
   end if
   -- put hArray_GetCalls (foundCall, hArray) into shortCalls
   put hkey_FetchShortCalls (foundCall) into shortCalls
   
   repeat for each line shortCall in shortCalls
      hArray_SimpleWalk shortCall, foundCall, hKeyLinkArray, pEnvironmentFilter, pTestExceptions, pOriginalHkey
   end repeat
   return newlyExportedHkeyArray
end hArray_SimpleWalk

command hkey_WalkHierarchy hKey, @hKeyLinkArray, thisDepth, pMaxDepth, pDontRecurseOutside, pOriginalHkey, pEnvironmentFilter, pTestExceptions, pForceSearch
   breakpoint
   put hKey
   -- based on "script_WalkHierarchy"
   -- tweaked logic with "the hkey_SearchHierarchy [pEnvironmentFilter] of someObject"
   if hKeyLinkArray [hKey] is not empty then return empty -- no need to recurse
   if pMaxDepth is not a number then put empty into pMaxDepth
   if the commandkey is "Down" and the optionKey is "Down" then
      hkey_Deconstruct pOriginalHkey, oHandlerName, oHandlerType, oScriptObject, oHandlerNum
      put "Currently indexing" && kwote (hKey) into pTitle
      display_ObjectHKeyArray hKeyLinkArray, oScriptObject, empty, empty, pTitle
      put the result into treeView
      set the displayed_Hkey of treeView to hKey
      
      -- allow storing of work-in-progress (by refering to last hKey)
      -- give an export!
      breakpoint
   end if
   
   hkey_Deconstruct hKey, handlerName, handlerType, scriptObject, handlerNum
   
   -- hack for exceptions
   if pTestExceptions is not false then
      if hkey_DontRecurse (hKey, pOriginalHkey) is true then
         return empty
      end if
   end if
   
   -- outside object?
   if pDontRecurseOutside is true then
      hkey_Deconstruct pOriginalHkey, oHandlerName, oHandlerType, oScriptObject, oHandlerNum
      if scriptObject is not oScriptObject then
         -- it is outside the original object, so don'd add and recurse
         -- the hKey has already been added as a link to
         return empty
      end if
   end if
   
   -- OK, lets go ahead and process for adding
   -- is there a bug here as should add here not before recursion?
   opn_Notify (item 1 of hKey)
   
   put the hkey_SearchHierarchy [pEnvironmentFilter] of scriptObject into fullScriptHierarchy
   put hkey_SearchObjectHierarchy (hKey, fullScriptHierarchy) into messagePassHierarchy -- not finding private handlers in the hkey object?
   
   if messagePassHierarchy is empty then
      -- bug:   hkey_SearchObjectHierarchy not finding private handlers?
      put merge ("Cannot find '[[hKey]]' using 'hkey_SearchObjectHierarchy (hKey, fullScriptHierarchy)'!") into someMessage
      opn_Notify someMessage, true
      put scriptObject into someObject -- in case messagePassHierarchy is empty?
   end if
   
   repeat with lineNum = (the number of lines of messagePassHierarchy) down to 1
      set the cursor to busy
      
      -- lets do some checks and get then last object in what is left of the hiearchy
      if the commandkey is "Down" then
         hkey_Deconstruct pOriginalHkey, oHandlerName, oHandlerType, oScriptObject, oHandlerNum
         display_ObjectHKeyArray hKeyLinkArray, oScriptObject, empty, oHandlerName
         breakpoint
      end if
      
      put line lineNum of messagePassHierarchy into someObject
      if exists(someObject) is false then
         next repeat	# just in case
      end if
      
      -- construct actual hkey for the object the handler was found in
      put hkey_Construct (handlerName, handlerType, someObject) into foundHkey
      
      -- lets check if somehow we have already indexed this foundHkey
      if foundHkey is among the lines of keys (hKeyLinkArray) then
         get "it already been indexed. Lets not index it again please :)"
      else   
         -- lets get the call in whats left of hierarchy
         put the script_Handler [foundHkey] of someObject into someHandler
         put library_FetchHandler (hKey) into storedHandler
         if someHandler = storedHandler and pForceSearch is not true then
            -- already stored, faster to fetch stored calls
            put hkey_GetCalls (hKey) into handlerCalls
         else
            put the hkey_SearchHierarchy [pEnvironmentFilter] of someObject into fullScriptHierarchy
            put script_ParseHandlerForCalls (someHandler, fullScriptHierarchy, someObject) into handlerCalls
            hkey_StoreCallsAndHandler foundHkey, someHandler, handlerCalls
         end if
         
         if handlerCalls is empty then
            put empty into hKeyLinkArray [foundHkey]
         end if
         
         put thisDepth + 1 into nextDepth	# will need to go down 1 level
         if skipRecursion is true or pMaxDepth is not empty and nextDepth > pMaxDepth then
            -- lets not recurse any deeper
            put thisDepth - 1 into nextDepth	# probably not needed
         else
            -- now lets repeat and recurse for each call found
            repeat for each line linkCall in handlerCalls
               hkey_Deconstruct linkCall, linkName, linkType, linkObject, linkNum
               
               if exists(linkObject) is false then
                  if the script_SkipMissing of me is true then
                     next repeat
                  end if
               end if
               if linkType is among the items of "g,s" then
                  put script_GetPropertyTarget (linkName, someHandler, someObject) into propertyTarget -- total hack !!!
                  if exists (propertyTarget) is false then
                     put "script_GetPropertyTarget" && linkName & "," && someObject into someError
                     -- log_Error someError, "script_GetPropertyTarget error!"
                     opn_Notify someError, true
                     put someObject into propertyTarget -- total hack !!!
                  end if
                  
                  -- now find property linkName in the hkey_SearchHierarchy of propertyTarget
                  put hkey_Construct (linkName, linkType, propertyTarget, linkNum) into testKey
                  put the hkey_InHierarchy [testKey] of propertyTarget into propertyHandlerObject
                  if exists (propertyHandlerObject) is false then
                     -- it is a plain custom property
                     put propertyTarget into propertyHandlerObject
                     if the script_SkipMissing of me is true then next repeat -- ???
                     
                     -- mark as "missing" ???
                     put "Custom property of" && propertyHandlerObject into missingPropertyCall
                     -- put "Custom Property" into missingPropertyCall
                     put hkey_Construct (linkName, linkType, missingPropertyCall, linkNum) into linkCall
                  else
                     -- we have found a custom property handler in the hierarchy
                     -- not sure how but should mark property as plain custom property (not handled by a custom handler)
                     put hkey_Construct (linkName, linkType, propertyHandlerObject, linkNum) into linkCall
                  end if
               end if
               
               -- add and recurse
               array_AddToIndex linkCall, foundHkey, hKeyLinkArray
               hkey_WalkHierarchy linkCall, hKeyLinkArray, nextDepth, pMaxDepth, pDontRecurseOutside, pOriginalHkey, pEnvironmentFilter, pTestExceptions, pForceSearch
            end repeat
         end if
      end if
      
      -- if the handler has been passed
      -- seems like a hack to me!
      put line (lineNum - 1) of messagePassHierarchy into messagePassObject
      if exists (messagePassObject) is false then
         next repeat -- or should it be exit repeat
      else
         breakPoint 
         put hkey_Construct (handlerName, handlerType, messagePassObject) into messagePassHkey
         array_AddToIndex messagePassHkey, foundHkey, hKeyLinkArray
      end if
   end repeat
   
   -- finished hierarchy but still may be trying to pass somewhere (hopefuly the system)
   -- would be better and faster if this were part of "hkey_InHierarchy" ???
   
   if exists (someObject) is false then
      breakPoint
      return empty	# not sure why this would be?
   end if
   
   put the script_Handler [foundHkey] of someObject into someHandler
   hkey_Deconstruct foundHkey, handlerName, handlerType, targetObject, handlerNum
   if script_HandlerContainsPass (handlerName, someHandler) is true then
      switch
         case char 1 of handlerType is among the items of "m,g,s"
            -- if handerName is a revMessage, then don't index missing passed system messages
            return empty
         case handlerName is among the items of "CloseFieldEditor"
            -- a datagrid method
            return empty
         default
            put hkey_Construct (handlerName, handlerType, "Missing") into pKey
            array_AddToIndex pKey, foundHkey, hKeyLinkArray
            if hKeyLinkArray [pKey] is empty then
               array_AddToIndex empty, pKey, hKeyLinkArray
            end if
      end switch
   end if
end hkey_WalkHierarchy

function hkey_MissingHandlerIsNotImportant callName, callType
   switch
      case callType is among the items of "g,s"
         -- if not found, then it's OK for get/setprops
         -- put hkey_Construct (callName, callType, "missing custom", 1) into foundCall
         -- array_AddToIndex empty, foundCall, hKeyLinkArray
         return true
      case char 1 to 3 of callName = "rev" and char 4 of callName is not "_"
         -- it should not have been indexed as it is a LiveCode IDE handler
         return true
      case the number of words of callName > 1
         -- bug - often "default -- case"
         put merge ("Bug with call '[[shortCall]]' for handler '[[hKey]]'") into someMessage
         opn_Notify someMessage, true
         return true
      default
         return false
   end switch
end hkey_MissingHandlerIsNotImportant
