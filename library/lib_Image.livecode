script "lib_Image"
--> MetaData
-
license: GPLv3
name: lib_Image
type: script library
version: 0.1

/*
This library is where we collect usefull handlers for manipulating images.

At present it is an old library full of stuff from ages ago.
needs sorting and working out what is actually useful.
*/


--> Image
-
function image_Find imageID, pStackNames
   -- good for finding icons of buttons
   if pStackNames is empty then put revLoadedStacks("all") into pStackNames
   repeat for each line stackName in pStackNames
      if exists(image id imageID of stack stackName) then
         put the long id of image id imageID of stack stackName into imageObject
         return imageObject
      end if
   end repeat
   return empty
end image_Find

function image_FileTypeFromPath imageFile
    put image_TypeFromPath(imageFile) into imageType
    return image_GetFileType(imageType)
end image_FileTypeFromPath

function image_TypeFromPath imageFile
   -- can use platform specific command line stuff
   file_Deconstruct imageFile, someRoot, shortName, imageExtension
   return imageExtension
end image_TypeFromPath


--> Image | QR Code
-
setprop image_QrCode someText
   put the long id of the target into imageObject
   put the width of imageObject into someWidth
   put the height of imageObject into someWidth
   put image_FetchQrCode (someText, someWidth, someHeight) into someImage
   set text of imageObject to someImage
end image_QrCode

function image_FetchQrCode someText, someWidth, someHeight
   put "http://api.qrserver.com/v1/create-qr-code/?data=" & urlencode(someText) into someUrl
   put "&size=" & someWidth & "x" & someHeight after someUrl
   put url someUrl into someImage
   return someImage
end image_FetchQrCode


--> Image | OCR
-
function image_TiffToText someFile, pOutputName
    set the cursor to watch
    if pOutputName is empty then put "result" into pOutputName
    
    file_Deconstruct someFile, someRoot, shortName, fileExtension
    set the itemdelimiter to "/"
    put item -1 of someFile into shortFile
    
    shell_BashParamEscape shortFile
    shell_BashParamEscape pOutputName
    put merge("tesseract [[shortFile]] [[pOutputName]]") into someShell
     
    put shell_ExecuteAtRoot(someShell, someRoot) into shellResult
    if word 1 of shellResult = "Tesseract" then
        put file_Construct(someRoot, pOutputName, "txt") into textFile
        opn_Notify textFile
        return url ("file:" & textFile)
    else
        log_Error "Tesseract error", shellResult, true, true
        return empty
    end if
end image_TiffToText

function image_TypeFromContents imageContents
    put char 1 to 10 of imageContents into imageHeader
    if imageHeader contains "JFIF" then
        return "JPEG"
    else if imageHeader contains "PNG" then
        return "PNG"
    else if imageHeader contains "GIF89" then
        return "GIF"
    end if
end image_TypeFromContents

function image_DetectType someImage
   -- based on function "revImageType" of the revbackScript
   --take the numbered image and return a three character file extension for it
   local tHeader
   
   put char 1 to 100 of someImage into tHeader
   if charToNum(char 1 of tHeader) is 137 and char 2 to 4 of tHeader is "PNG" then return "png"
   if charToNum(char 1 of tHeader) is among the items of "255,216" and "JFIF" is in tHeader then return "jpg"
   if "GIF" is in tHeader then return "gif"
   --PICT
   --can't get the code to detect this right, use internal format
   --default
   --edited in mc or recompressed by MC (imported BMP, XWD etc.)
   return "ppm"
end image_DetectType

function image_IsPict someImage
   -- based on function "revIsPICT" of the revbackScript
   --takes a valid file path and returns if PICT or not
   local tPICT
   
   put char 1 to 600 of someImage into someImage
   repeat with i = 1 to 7
      if charToNum(char i of someImage) is 0 then
         put true into tPICT
      else
         put false into tPict
         exit repeat
      end if
   end repeat
   if tPict then
      if charToNum(char 523 of someImage) is 0 and charToNum(char 524 of someImage) is 17 and charToNum(char 525 of someImage) is 2 and charToNum(char 526 of someImage) is 255 then
         put true into tPict
      else
         put false into tPict
      end if
      
      local tFinal
      if tPict then
         put true into tFinal
      else
         put false into tFinal
      end if
   else
      put false into tFinal
   end if
   return tFinal
end image_IsPict

function image_GetFileType imageType
    switch imageType
        case "JPG"
            return "prvwJPEG"
        case "JPEG"
            return "prvwJPEG"
        case "GIF"
            return "prvwGIFf"
            break
        case "PNG"
            return "prvwPNGf"
    end switch
end image_GetFileType

--> Image | Import
-
command image_ImportFileData imageObject
    put the filename of imageObject into imageFile
    if imageFile is empty then return empty
    
    put url ("binfile:" & imageFile) into someImage
     
    put the long id of imageObject into imageObject
    get "put someImage into" && imageObject
    do it
    set the image_OriginalFile of imageObject to imageFile
    return someImage
     
    put the short id of imageObject into photoID
    put object_ExtractStack(imageObject) into imageStack
    put someImage into image id photoID of imageStack
     
    return someImage
end image_ImportFileData

function image_FileDimensions imageFile
   switch the platform
      case "MacOS"
         -- should check for OSX
         put spotlight_GetFileInfo (imageFile) into spotlightFileInfo
         put spotlight_ExtractAttribute (spotlightFileInfo, "kMDItemPixelWidth") into pixelWidth
         put spotlight_ExtractAttribute (spotlightFileInfo, "kMDItemPixelHeight") into pixelHeight
         return pixelWidth,pixelHeight
         break
      default
         breakPoint
         return empty
   end switch
end image_FileDimensions

function image_FileWidth imageFile
   switch the platform
      case "MacOS"
         put spotlight_GetFileInfo (imageFile) into spotlightFileInfo
         put spotlight_ExtractAttribute (spotlightFileInfo, "kMDItemPixelWidth") into pixelWidth
         return pixelWidth
         break
      default
         breakPoint
         return empty
   end switch
end image_FileWidth
    

command image_ExportToFile viewOrImage, pSaveToFile, pExtension
    put the image_Object of viewOrImage into imageObject
    if exists(imageObject) is false then return false
     
    if pSaveToFile is empty then put image_ChooseSaveToFile() into pSaveToFile
     
    if pExtension is empty then
        file_Deconstruct pSaveToFile, someRoot, shortName, pExtension
        if pExtension is empty then put "png" into pExtension
    end if
    
    put the filename of imageObject into linkedImageFile
    if linkedImageFile is not "" then
        file_ConvertImageFormat linkedImageFile, pSaveToFile, pExtension
        return the result is empty
    else if pExtension = "tiff" then
        -- its not a linked file and we want to export as a tiff
        put the tempname & ".png" into inputFile
        image_RevExport imageObject, inputFile, "png"
        file_ConvertImageFormat inputFile, pSaveToFile, "tiff"
    else if pExtension is among the items of rev_ImageExportFormats() then
        image_RevExport imageObject, pSaveToFile, pExtension
    end if
    return pSaveToFile
end image_ExportToFile

command image_Export imageObject, pSavedFile, pImageFileType
   put the short id of imageObject into imageID
   put the stack_Object of imageObject into stackObject
   put the defaultstack into oStack
   set the defaultstack to stackObject
   
   if pSavedFile is empty then
      put merge("Export this image as a [[imageFileType]]...") into someComment
      ask file someComment
      put it into pSavedFile
      if pSavedFile is empty then exit to top
   end if
   
   if the platform is MacOS then
      put the filetype into oFileType
   end if
   
   switch pImageFileType
      case "JPG"
         set the filetype to "prvwJPEG"
         export image id imageID to file pSavedFile as JPEG 
         break
      case "JPEG"
         set the filetype to "prvwJPEG"
         export image id imageID to file pSavedFile as JPEG 
         break
      case "GIF"
         export image id imageID to file pSavedFile as GIF 
         break
      default
         set the filetype to "prvwPNGf"
         export image id imageID to file pSavedFile as PNG 
   end switch
   
   if the platform is MacOS then
      set the filetype to oFileType
   end if
   set the defaultstack to oStack
   return pSavedFile
end image_Export

command image_RevExport imageObject, pSaveToFile, fileExtension
   -- exports the image at the size it is shown
   
   put image_GetFileType(fileExtension) into imageFileType
   put the filetype into oFileType
   set the filetype to imageFileType
   put merge("export [[imageObject]] to file '[[pSaveToFile]]' as [[fileExtension]]") into doScript
   replace "'" with quote in doScript
   try
      do doScript
      return empty
   catch errorNum
      log_Error doScript, errorNum, true, true
      return errorNum
   end try
end image_RevExport

on file_ConvertImageFormat inputFile, saveToFile, imageExportFormat
    -- just using SIPS on OSX for now
    switch 
        case the platform = "MacOS" and the systemversion > 10
            sips_ConvertImageFormat inputFile, saveToFile, imageExportFormat
            return the result
        default
            return false
    end switch
end file_ConvertImageFormat


--> EXIF
-
function exif_IsInstalled
   put shell ("exiftool --help") into shellResult
   
   if shellResult contains "exiftool: command not found" then
      return false
   else
      return true
   end if
end exif_IsInstalled

function exif_GetTag tagName, imageFile, padded
    put exif_GetTagLine(tagName, imageFile, empty) into tagLine
    return tagLine
    
    -- using exif (http://libexif.sourceforge.net/ http://exif.darwinports.com/)
    shell_BashParamEscape imageFile
    shell_BashParamEscape tagName
    put "exif -t" && tagName && imageFile into someShell
    return shell(someShell)
end exif_GetTag

function exif_GetTagLine tagName, imageFile, padded
    --  Using exiftool (http://sno.phy.queensu.ca/%7Ephil/exiftool/exiftool_pod.html#reading_examples)
    shell_BashParamEscape imageFile
    
    if padded is true then
        put "exiftool -s -" & tagName && imageFile into someShell
    else
        put "exiftool -s -s -" & tagName  && imageFile into someShell
    end if
    put someShell
    return shell(someShell)
end exif_GetTagLine

function exif_GetMetaDataArray imageFile
    put exif_GetMetaData(imageFile) into metaDataArray
    replace ": " with tab in metaDataArray
    split metaDataArray with CR and tab
    return metaDataArray
end exif_GetMetaDataArray

function exif_GetMetaData imageFile, pretty
    /*
    Using exiftool (http://sno.phy.queensu.ca/%7Ephil/exiftool/exiftool_pod.html#reading_examples)
    print all meta information in an image, including duplicate and unknown tags, sorted by group (for family 1).
    */
    
    shell_BashParamEscape imageFile
    if pretty is true then
        put "exiftool -s -a -u -g1" && imageFile into someShell
    else
        put "exiftool -s -s -u" && imageFile into someShell
    end if
    return word 1 to -1 of shell(someShell)
end exif_GetMetaData

-- on exif_SetTag tagName, imageFile, tagValue
    shell_BashParamEscape imageFile
    shell_BashParamEscape tagName
    put "exif -t" && tagName && imageFile into someShell
    return shell(someShell)
end exif_SetTag

function exif_ListTags imageFile
    shell_BashParamEscape imageFile
    
    -- using exiftool (http://sno.phy.queensu.ca/%7Ephil/exiftool/exiftool_pod.html#reading_examples)
    put "exiftool -list" && imageFile into someShell
    put shell(someShell) into shellResult
    put exif_ParseExifToolResult(shellResult, tagArray) into tagNames
    return tagNames
    
    get keys(tagArray)
    sort it
    replace "/" with "_" in it
    return it
     
    -- using exif (http://libexif.sourceforge.net/ http://exif.darwinports.com/)
    put "exif -l" && imageFile into someShell
    return exif_ParseTagList(shellResult, tagArray)
end exif_ListTags

function exif_ParseExifToolResult shellResult, @tagArray
    put lineoffset("Command-line shortcuts:",shellResult) into lineNum
    put line 2 to (lineNum-1) of shellResult into availableTagNames
    -- put line (lineNum+1) of shellResult into shortCuts
    put line (lineNum+2) to -1 of shellResult into exifTable
     
    set the itemdelimiter to ":"
    repeat for each line exifLine in exifTable
        put word 1 to -1 of item 1 of exifLine into tagName
        put word 1 to -1 of item 2 of exifLine into tagValue
        put tagValue into tagArray [tagName]
    end repeat
     
    replace CR & "  " with CR in availableTagNames
    replace space with CR in availableTagNames
    delete char 1 to 2 of availableTagNames
    
    return word 1 to -1 of availableTagNames
end exif_ParseExifToolResult

function exif_ParseTagList shellResult, @tagArray, allTags
    set the itemdelimiter to tab
    -- put shellResult
    delete line 1 of shellResult
    replace "  " with tab in shellResult
    -- if allTags is not true then filter shellResult with "*[*]*"
    -- put shellResult
    repeat for each line someLine in shellResult
        get item 2 of shellResult
        put word 1 of it into someID
        put word 2 to -1 of item 2 of someLine into tagName
        put someID into tagArray [tagName]
    end repeat
    put keys(tagArray) into tagNames
    sort tagNames
    return tagNames
end exif_ParseTagList


--> Image | SIPS
-
/*
Ian Wood <revlist@azurevision.co.uk>

-r degreesCW
--rotate degreesCW

-f horizontal|vertical
--flip horizontal|vertical

-c pixelsH pixelsW
--cropToHeightWidth pixelsH pixelsW
Crop image to fit specified size.

-p pixelsH pixelsW
--padToHeightWidth pixelsH pixelsW
Pad image with pixels to fit specified size.

--padColor hexcolor
Use this color when padding. White=FFFFFF, Red=FF0000, Default=Black=000000

-z pixelsH pixelsW
--resampleHeightWidth pixelsH pixelsW
Resample image at specified size. Image apsect ratio may be altered.

--resampleWidth pixelsW
Resample image to specified width.

--resampleHeight pixelsH
Resample image to specified height.
*/

on sips_ConvertImageFormat inputFile, saveToFile, imageExportFormat
    -- need to be long file names or set the default folder
    if imageExportFormat = "jpg" then put "jpeg" into imageExportFormat
    if imageExportFormat is not among the items of sips_ExportFormats() then
        put "Export format not recognised by sips" into someError
        log_Error someError, imageExportFormat, true, true
        return someError
    end if
     
    shell_BashParamEscape inputFile
    shell_BashParamEscape saveToFile
    put merge("sips -s format [[imageExportFormat]] [[inputFile]] --out [[saveToFile]]") into someShell
    put shell(someShell) into shellResult
    return shellResult
end sips_ConvertImageFormat

command sips_SetWidth imageFile, someWidth
   /*
   --resampleWidth pixelsW
   Resample image to specified width.
   */
   put shell_MakeOSXShellPath (imageFile) into imageFile
   put "sips --resampleWidth" && someWidth && imageFile into someShell
   put shell (someShell) into shellResult
   return shellResult
end sips_SetWidth

function sips_RotateImage tInput, tDegrees, tOutput
    -- was "ijwAPLIB_SIPSRotateImage"
    if tDegrees = 0 then return true
    put shell_MakeOSXShellPath(tInput) into tShellInput
    put "sips -r" && tDegrees && tShellInput into tScript
    if tOutput is not empty then
        put shell_MakeOSXShellPath(tOutput) into tShellOutput
        put space & tShellOutput after tScript
    end if
    return shell(tScript)
end sips_RotateImage

function sips_ImageInfo tPath, tInfo
    -- was "ijwAPLIB_SIPSImageInfo"
    put shell_MakeOSXShellPath(tPath) into tPath
    put "sips -g" && tInfo into tScript
    put space & tPath after tScript
    get shell(tScript)
    put last word of it into tResult
    if tResult = "<nil>" then return empty
    return tResult
end sips_ImageInfo

function sips_ExportFormats
    return "jpeg,tiff,png,gif,-,jp2,pict,bmp,qtif,psd,sgi,tga"
end sips_ExportFormats

function sips_Formats
   return "jpeg,tiff,png,gif,jp2,pict,bmp,qtif,psd,sgi,tga"
end sips_Formats

function shell_MakeOSXShellPath tPath
    -- was "ijwAPLIB_MakeOSXShellPath"
    put "set tOut to quoted form of POSIX path of tPath" into tScript
    replace "tPath" with quote & revMacFromUnixPath(tPath) & quote in tScript
    do tScript as applescript
    put the result into tNewPath
    delete char 1 of tNewPath
    delete last char of tNewPath
    return tNewPath
end shell_MakeOSXShellPath


--> Image | Snapshot
-
function image_GetSnapShot imageViewOrRect, imageType
    lock screen
    if imageViewOrRect is a rect then
        put imageViewOrRect into globalRect
    else if exists(imageViewOrRect) then
        put the image_Object of imageViewOrRect into imageObject
         
        -- don't snap the frame (and get global rect)
        put the showborder of imageObject into oShowBorder
        set the showborder of imageObject to false
        put the rect of imageObject into imageRect
         
        /*
        put the borderwidth of imageObject into someBorder
        put rect_SubtractMargin(someBorder, imageRect) into imageRect
        */
         
        put object_ExtractStackName(imageObject) into stackName
        put rect_GetGlobal(imageRect, stackName) into globalRect
    end if
     
    switch imageType
        case "GIF"
            export snapshot from rect globalRect to someImage as GIF
            break
        case "JPG"
            export snapshot from rect globalRect to someImage as JPEG
            break
        case "JPEG"
            export snapshot from rect globalRect to someImage as JPEG
            break
        default
            export snapshot from rect globalRect to someImage as PNG
    end switch
    
    if exists(imageObject) then set the showborder of imageObject to oShowBorder
    unlock screen
    return someImage
end image_GetSnapShot

on image_SnapRect gRect, someFile, imageFileType
    if someFile is empty then
        put merge("Export this image as a [[imageFileType]]...") into someComment
        ask file someComment
        put it into someFile
        if somefile is empty then exit to top
    end if
    if imageFileType is empty then
        -- guess from file extension
        file_Deconstruct someFile, someRoot, shortName, imageExtension
        if imageExtension is empty then put "png" into imageExtension
        put image_GetFileType(imageExtension) into imageFileType
    end if
     
    put the filetype into oFileType
    set the filetype to imageFileType
     
    -- export snapshot from rect "0,0,200,200" to file "Nav.jpg" as JPEG
    put merge("export snapshot from rect '[[gRect]]' to file '[[someFile]]' as [[imageFileType]]") into doScript
    replace "'" with quote in doScript
    do doScript
     
    set the filetype to oFileType
    return someFile
end image_SnapRect

on image_SnapshotStack stackObject, someFile, imageFileType
    if someFile is empty then
        put merge("Export this image as a [[imageFileType]]...") into someComment
        ask file someComment
        put it into someFile
        if somefile is empty then exit to top
    end if
    if imageFileType is empty then
        -- guess from file extension
        file_Deconstruct someFile, someRoot, shortName, imageExtension
        if imageExtension is empty then put "png" into imageExtension
        put image_GetFileType(imageExtension) into imageFileType
    end if
    
    put the windowid of stackObject into someWindowID
    put the rect of stackObject into stackRect
    put the rect of card 1 of stackObject into cardRect
    
    put the filetype into oFileType
    set the filetype to imageFileType
     
    put merge("export snapshot from rect '[[cardRect]]' of window [[someWindowID]] to file '[[someFile]]' as [[imageFormat]]") into doScript
    -- put merge("export snapshot from rect '[[stackRect]]' to file '[[someFile]]' as [[imageFormat]]") into doScript
     
    replace "'" with quote in doScript
    put doScript
    breakpoint
    do doScript
     
    set the filetype to oFileType
    return someFile
end image_SnapshotStack

function image_ChooseSaveToFile
    put merge("Export this image to...") into someComment
    ask file someComment
    put it into pSaveToFile
    if pSaveToFile is empty then exit to top
    return pSaveToFile
end image_ChooseSaveToFile


--> Image | Groups
-
on image_ExportFromIDs imageIDs, someFolder
    repeat for each item imageID in imageIDs
        put image_FindFromID(imageID) into imageObject
        put the image_GuessFileName [someFolder] of imageObject into someFile
        set the image_FileExport of imageObject to someFile
    end repeat
end image_ExportFromIDs

function image_FindFromID imageID, someStacks
    if someStacks is empty then put the mainstacks into someStacks
    repeat for each line stackName in someStacks
        set the cursor to busy
        if exists(image id imageID of stack stackName) then
            put the long id of image id imageID of stack stackName into imageObject
            put imageObject & CR after imageObjects
        end if
         
        repeat for each line subStackName in the substacks of stack stackName
            if exists(image id imageID of stack subStackName of stack stackName) then
                put the long id of image id imageID of stack stackName into imageObject
                put imageObject & CR after imageObjects
            end if
        end repeat
    end repeat
    delete last char of imageObjects
    return imageObjects
end image_FindFromID

getprop image_GuessFileName [someFolder]
    put the long id of the target into imageObject
     
    get the short name of imageObject
    file_Deconstruct it, someRoot, shortName, fileExtension
    if fileExtension is empty then
        put tolower(it) & ".png" into shortFile
        replace space with "_" in shortFile
    else
        put it into shortFile
    end if
    put the short id of imageObject & "_" before shortFile
    
    if someFolder is empty then
        return shortFile
    else
        folder_Format someFolder
        put someFolder & shortFile into someFile
        return someFile
    end if
end image_GuessFileName


function image_GetRevCropped cropRect, imageView
    put the image_Object of imageView into imageObject
     
    lock screen
    put the rect of imageView into oRect
    image_ImportFileData imageObject
    put the result into someImage
    if someImage is empty then put the image_Contents of imageView into someImage
     
    if cropRect is empty then
        put the image_CropArea of imageView into cropRect
        if cropRect is empty then
            return empty
        else
            set the image_CropArea of imageView to empty
        end if
    end if
    put image_RectToAbsolute(cropRect, imageView) into relativeCropRect
     
    put the resize_Style of imageView into oStyle
    put the image_Magnification of imageView into oMagnification
    put the image_Scroll of imageView into oScroll
    
    set the image_Magnification of imageView to 1
    -- set the resize_Style of imageView to "centre"
     
    put image_AbsoluteToRect(relativeCropRect, imageView) into originalCropRect
     
    put the short id of imageObject into imageID
    crop image id imageID to originalCropRect
    put the image_Contents of imageView into croppedImage
    set the image_Contents of imageView to someImage
    
    set the image_Magnification of imageView to oMagnification
    set the resize_Style of imageView to oStyle
    set the image_Scroll of imageView to oScroll
    -- set the view_Rect of imageView to oRect
    -- set the image_CropArea of imageView to cropRect
    unlock screen
     
    -- rect_CreateMask originalCropRect, "Test", imageView
    return croppedImage
end image_GetRevCropped
